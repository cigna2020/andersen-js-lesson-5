/* Ситуация №1:
1.  button.addEventListener('click', () => {
2.    Promise.resolve().then(() => console.log('Microtask 1'));
3.    console.log('Listener 1');
4.  });
5.
6.  button.addEventListener('click', () => {
7.    Promise.resolve().then(() => console.log('Microtask 2'));
8.    console.log('Listener 2');
9.  });
Вопрос: в каком порядке будут выведены в консоль сообщения, когда пользователь кликнет по кнопке button? */


/* Привет!
Думаю, порядок выполнения будет следующим:

После попадания в Call Stack такие обработчики события НЕ выполняются, а перемещаются в web API (предполагаю, что работаем в браузере),
как зарегистрированный обработчик события на документе и ожидают самого события.
После получения уведомления о срабатывании события ‘click’, наши события по принципу «первым пришел – первым ушел» (FIFO) поступают в Task queue.
Если Call Stack пуст, Event loop передает туда первую функцию для выполнения.
В ходе выполнения такой функции Call Stack (образно, Call Stack – это очередь))) сначала встречает Promise, который является Callback function и отправляет его снова в очередь.
Но в связи с тем, что Promise относится к микро-таскам, то такая функция попадает не в «общую» очередь, а в очередь с более высоким приоритетом.
После чего будет выполнена следующая строка кода => console.log('Listener 1').
Таким образом, после console.log('Listener 1') в Task queue ожидает своей очереди функция по следующему из очереди событию,
но в тоже время, в очереди микро-тасков стоит Promise 'Microtask 1'.
Как уже упоминалось, задачи с очереди микро-тасков имею более высокий приоритет над задачами с Task queue.
Более того, Event loop будет отправлять в Call Stack функции из очереди микро-тасков до тех пор, пока они не закончатся.
В связи с этим, следующим мы увидим => console.log('Microtask 1')
Далее по аналогии, сначала console.log('Listener 2'), потом Promise на второй круг и console.log('Microtask 2')

Таким образом, увидим следующий порядок выполнения:
console.log('Listener 1');
console.log('Microtask 1');
console.log('Listener 2');
console.log('Microtask 2') */

// ============================================================================================================================

/* Ситуация №2:
1.    button.addEventListener('click', () => {
2.      Promise.resolve().then(() => console.log('Microtask 1'));
3.      console.log('Listener 1');
4.    });
5.
6.    button.addEventListener('click', () => {
7.      Promise.resolve().then(() => console.log('Microtask 2'));
8.      console.log('Listener 2');
9.    });
10.
11. button.click();
Вопрос: в каком порядке будут выведены в консоль сообщения, когда выполнится код выше? Будет ли разница с первым вариантом?*/


/* Честно говоря, сначала решил, что разницы не будет.
Но когда запустил код то понял, что был неправ. И вот почему:
Разница между первым и вторым вариантом в том, что во втором варианте мы сразу же вызываем событие.
Таким образом «слушатели» не попадают в API и остаются в очереди Call Stack для выполнения функций по порядку (сверху вниз).
Сначала, как и в первой ситуации, встречается Promise, который является Callback function и сразу же отправляется в очередь.
Но в данном случае приоритет очереди не имеет значения потому, что после выполнения следующей после Promise строки,
это => console.log('Microtask 1'), Call Stack все еще будет занят функциями «второго» события
и Event loop не будет обращаться к какой-либо очереди до момента полного освобождения Call Stack.
В связи с этим, после отправки первого Promise в очередь и после выполнения console.log('Microtask 1'), в Call Stack придет очередь «второго» события.
Снова сначала встретится Promise, который тоже будет отправлен в очередь.
И после выполнения console.log('Listener 2') в дело вступит Event loop.
Учитывая, что в очереди соблюдается принцип FIFO, следующим в Call Stack и в консоли мы увидим
=> console.log('Microtask 1'), ну и в конце => console.log('Microtask 2').

Таким образом, увидим следующий порядок выполнения:
console.log('Listener 1');
console.log('Listener 2');
console.log('Microtask 1');
console.log('Microtask 2') */